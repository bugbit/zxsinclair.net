@page "/performsyncnotask"
@using System.Diagnostics;
@using ZXSinclair.Machines;
@using ZXSinclair.Machines.Z80;
@inject IJSRuntime JS;

<div>
	@foreach (var msg in msgs)
	{
		<p>@msg</p>
	}
</div>

@code
{
	public class MachineZ80Test : MachineZ80
	{
		private RAM mRam = new RAM(0xFFFF);

		public MachineZ80Test()
		{
		}

		protected override IMemory[] CreateMemories()
		{
			return new[] { mRam };
		}

		public override byte PeekByte(int argAddress) => mRam.ReadMemory(argAddress & 0xFFFF);
		public override void Poke(int argAddress, byte argData) => mRam.WriteMemory(argAddress & 0xFFFF, argData);
		@* protected override void Sync()
			{
			//base.Sync();
			mFinishToken.Cancel();
			} *@
	}

	List<string> msgs;
	MachineZ80Test machine;
	private System.Timers.Timer mTimerFrame;
	private Stopwatch mWatchFrame, mWatchFPS;
	private int mFPS = 50;
	private int mFPSCalc = 0;

	protected override void OnInitialized()
	{
		base.OnInitialized();
		msgs = new List<string>();
		machine = new MachineZ80Test();
		mTimerFrame = new System.Timers.Timer(1000 / machine.FPS);
		mTimerFrame.Elapsed += OnTimerFrame_Elapse;
	}

	protected async override Task OnAfterRenderAsync(bool firstRender)
	{
		await base.OnAfterRenderAsync(firstRender);
		if (firstRender)
		{
			mWatchFrame = Stopwatch.StartNew();
			mWatchFPS = Stopwatch.StartNew();
			mTimerFrame.Start();
		}
	}

	private  void OnTimerFrame_Elapse(object source, System.Timers.ElapsedEventArgs e)
	{
		 machine.StepFrame();		

		var ellapsetime = mWatchFrame.ElapsedMilliseconds;
		// 20 -> 50

		mFPSCalc++;

		if (mWatchFPS.ElapsedMilliseconds > 1000)
		{
			mWatchFPS.Restart();
			mFPS = mFPSCalc;
			mFPSCalc = 0;
		}

		var msg = $"{mFPS} FPS {machine.TStates} ellapse : {ellapsetime}";

		mWatchFrame.Restart();
		Console.WriteLine(msg);
		msgs.Add(msg);
		StateHasChanged();
	}
}